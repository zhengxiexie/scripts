#!/usr/bin/env python3
"""
Confluence Publisher V3 - ‰ºòÂåñÁâàÊú¨
- ÊîØÊåÅË°®Ê†ºÂÆΩÂ∫¶ÊéßÂà∂
- ÊîπËøõ‰ª£Á†ÅÂùóÊòæÁ§∫Ôºà‰ΩøÁî® Confluence code macroÔºâ
- Êõ¥Â•ΩÁöÑ‰∏≠ÊñáÊîØÊåÅ

Usage:
    publish-to-confluence-v3 <markdown-file> [options]
    
Options:
    -s, --space SPACE       Confluence space key (default: NSBU)
    -p, --parent ID         Parent page ID (optional)
    -t, --title TITLE       Page title (optional, defaults to filename)
    -u, --update ID         Update existing page with this ID
    --url URL              Confluence URL (default: https://vmw-confluence.broadcom.net)
    -h, --help             Show this help message

Environment:
    CONFLUENCE_TOKEN       Required: Your Confluence Bearer token

Author: Xie Zheng
Version: 3.0.0
"""

import os
import sys
import json
import argparse
import requests
import subprocess
from pathlib import Path
from datetime import datetime
import tempfile
import re
import html

class ConfluencePublisher:
    def __init__(self, confluence_url=None, token=None):
        self.confluence_url = confluence_url or os.environ.get('CONFLUENCE_URL', 'https://vmw-confluence.broadcom.net')
        self.token = token or os.environ.get('CONFLUENCE_TOKEN')
        
        if not self.token:
            raise ValueError("CONFLUENCE_TOKEN environment variable is required")
        
        self.headers = {
            'Authorization': f'Bearer {self.token}',
            'Content-Type': 'application/json',
            'Accept': 'application/json'
        }
    
    def convert_markdown_to_storage(self, markdown_file):
        """Convert markdown to Confluence storage format"""
        # Check if pandoc is installed
        try:
            subprocess.run(['pandoc', '--version'], capture_output=True, check=True)
        except (subprocess.CalledProcessError, FileNotFoundError):
            print("Error: pandoc is not installed. Please install it first:")
            print("  brew install pandoc")
            sys.exit(1)
        
        # Read the markdown file
        with open(markdown_file, 'r', encoding='utf-8') as f:
            markdown_content = f.read()
        
        # Pre-process markdown to handle special cases
        markdown_content = self.preprocess_markdown(markdown_content)
        
        # Create temporary file for preprocessed content
        with tempfile.NamedTemporaryFile(mode='w+', suffix='.md', delete=False) as tmp_md:
            tmp_md.write(markdown_content)
            tmp_md_path = tmp_md.name
        
        # Create temporary file for converted content
        with tempfile.NamedTemporaryFile(mode='w+', suffix='.html', delete=False) as tmp_html:
            tmp_html_path = tmp_html.name
        
        try:
            # Convert using pandoc to HTML first
            cmd = ['pandoc', tmp_md_path, '-f', 'markdown', '-t', 'html', '--no-highlight', '-o', tmp_html_path]
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode != 0:
                print(f"Error converting markdown: {result.stderr}")
                return None
            
            # Read converted content
            with open(tmp_html_path, 'r', encoding='utf-8') as f:
                html_content = f.read()
            
            # Convert HTML to Confluence storage format
            storage_content = self.html_to_confluence_storage(html_content)
            
            return storage_content
        finally:
            # Clean up temp files
            if os.path.exists(tmp_md_path):
                os.unlink(tmp_md_path)
            if os.path.exists(tmp_html_path):
                os.unlink(tmp_html_path)
    
    def preprocess_markdown(self, content):
        """Preprocess markdown to handle special cases"""
        # Fix any HTML entities in markdown
        content = content.replace('&lt;', '<')
        content = content.replace('&gt;', '>')
        content = content.replace('&amp;', '&')
        
        # Ensure proper spacing around tables
        lines = content.split('\n')
        processed_lines = []
        in_table = False
        
        for i, line in enumerate(lines):
            # Check if line is a table row
            if '|' in line and line.strip().startswith('|'):
                if not in_table:
                    # Add blank line before table if needed
                    if i > 0 and processed_lines and processed_lines[-1].strip():
                        processed_lines.append('')
                    in_table = True
                processed_lines.append(line)
            else:
                if in_table:
                    # Add blank line after table if needed
                    if line.strip():
                        processed_lines.append('')
                    in_table = False
                processed_lines.append(line)
        
        return '\n'.join(processed_lines)
    
    def html_to_confluence_storage(self, html_content):
        """Convert HTML to Confluence storage format with optimizations"""
        storage = html_content
        
        # Process tables with width control
        storage = self.process_tables(storage)
        
        # Convert code blocks to proper Confluence code macro
        storage = self.process_code_blocks(storage)
        
        # Handle inline code
        storage = self.process_inline_code(storage)
        
        # Handle blockquotes
        storage = re.sub(r'<blockquote>\s*(?!<p>)', '<blockquote><p>', storage)
        storage = re.sub(r'(?<!p>)\s*</blockquote>', '</p></blockquote>', storage)
        
        # Clean up any remaining issues
        storage = self.clean_html(storage)
        
        return storage
    
    def process_tables(self, html_content):
        """Process tables with better width control"""
        def enhance_table(match):
            table_html = match.group(0)
            
            # Add tbody if not present
            if '<tbody>' not in table_html:
                table_html = table_html.replace('<table>', '<table><tbody>')
                table_html = table_html.replace('</table>', '</tbody></table>')
            
            # Analyze table content to determine if it needs width constraints
            # Count columns
            first_row = re.search(r'<tr[^>]*>(.*?)</tr>', table_html, re.DOTALL)
            if first_row:
                num_cols = len(re.findall(r'<t[hd][^>]*>', first_row.group(1)))
                
                # For tables with many columns or specific content patterns
                if num_cols >= 8:  # Like the summary table with 8 columns
                    # Add column width specifications for Confluence
                    colgroup = '<colgroup>'
                    # Adjust widths based on content type
                    # CRD PR | Category | Field Path | Type | Default | Description | Implementation PR | Author
                    widths = ['8%', '12%', '25%', '12%', '8%', '20%', '10%', '5%']
                    for width in widths[:num_cols]:
                        colgroup += f'<col style="width: {width};" />'
                    colgroup += '</colgroup>'
                    
                    table_html = table_html.replace('<table>', f'<table>{colgroup}')
                elif num_cols >= 2:  # For property description tables
                    # Check if it's a 2-column attribute-value table
                    if 'Attribute' in table_html and 'Value' in table_html:
                        colgroup = '<colgroup><col style="width: 30%;" /><col style="width: 70%;" /></colgroup>'
                        table_html = table_html.replace('<table>', f'<table>{colgroup}')
            
            return table_html
        
        # Process all tables
        storage = re.sub(r'<table[^>]*>.*?</table>', enhance_table, html_content, flags=re.DOTALL)
        
        return storage
    
    def process_code_blocks(self, html_content):
        """Convert code blocks to Confluence code macro format"""
        def convert_code_block(match):
            # Extract language and content
            full_match = match.group(0)
            
            # Check for language class
            lang_match = re.search(r'class="language-([^"]*)"', full_match)
            language = lang_match.group(1) if lang_match else 'text'
            
            # Extract code content
            code_match = re.search(r'<code[^>]*>(.*?)</code>', full_match, re.DOTALL)
            if code_match:
                code_content = code_match.group(1)
                
                # Decode HTML entities
                code_content = html.unescape(code_content)
                
                # For YAML files, use yaml language
                if language == 'yaml' or 'apiVersion' in code_content:
                    language = 'yaml'
                elif language == 'text' and ('$' in code_content or '#' in code_content[:50]):
                    language = 'bash'
                
                # Build Confluence code macro
                macro = f'<ac:structured-macro ac:name="code" ac:schema-version="1">'
                macro += f'<ac:parameter ac:name="language">{language}</ac:parameter>'
                macro += f'<ac:parameter ac:name="theme">Confluence</ac:parameter>'
                macro += f'<ac:parameter ac:name="linenumbers">false</ac:parameter>'
                macro += f'<ac:plain-text-body><![CDATA[{code_content}]]></ac:plain-text-body>'
                macro += f'</ac:structured-macro>'
                
                return macro
            
            return full_match
        
        # Process all code blocks
        storage = re.sub(r'<pre[^>]*><code[^>]*>.*?</code></pre>', 
                        convert_code_block, 
                        html_content, 
                        flags=re.DOTALL)
        
        return storage
    
    def process_inline_code(self, html_content):
        """Process inline code elements"""
        # Keep inline code but ensure it's properly formatted
        def format_inline_code(match):
            code_content = match.group(1)
            # Decode HTML entities
            code_content = html.unescape(code_content)
            # Encode for safety
            code_content = html.escape(code_content, quote=False)
            return f'<code>{code_content}</code>'
        
        storage = re.sub(r'<code>([^<]+)</code>', format_inline_code, html_content)
        return storage
    
    def clean_html(self, content):
        """Clean up HTML for Confluence"""
        # Remove empty paragraphs
        content = re.sub(r'<p>\s*</p>', '', content)
        
        # Clean up excessive whitespace
        content = re.sub(r'\n{3,}', '\n\n', content)
        
        # Ensure lists are properly formatted
        content = re.sub(r'<ul>\s*', '<ul>', content)
        content = re.sub(r'\s*</ul>', '</ul>', content)
        content = re.sub(r'<ol>\s*', '<ol>', content)
        content = re.sub(r'\s*</ol>', '</ol>', content)
        
        return content
    
    def get_page(self, page_id):
        """Get page information"""
        response = requests.get(
            f"{self.confluence_url}/rest/api/content/{page_id}?expand=version,ancestors",
            headers=self.headers
        )
        
        if response.status_code == 200:
            return response.json()
        return None
    
    def create_page(self, title, content, space_key, parent_id=None):
        """Create a new Confluence page"""
        payload = {
            'type': 'page',
            'title': title,
            'space': {'key': space_key},
            'body': {
                'storage': {
                    'value': content,
                    'representation': 'storage'
                }
            }
        }
        
        if parent_id:
            payload['ancestors'] = [{'id': parent_id}]
        
        response = requests.post(
            f"{self.confluence_url}/rest/api/content",
            headers=self.headers,
            data=json.dumps(payload)
        )
        
        if response.status_code == 200:
            return response.json()
        else:
            print(f"Error creating page: {response.status_code}")
            print(response.text[:500])
            return None
    
    def update_page(self, page_id, content, title=None):
        """Update an existing Confluence page"""
        # Get current page info
        page = self.get_page(page_id)
        if not page:
            print(f"Error: Could not fetch page {page_id}")
            return None
        
        current_version = page['version']['number']
        page_title = title or page['title']
        
        payload = {
            'version': {
                'number': current_version + 1
            },
            'title': page_title,
            'type': 'page',
            'body': {
                'storage': {
                    'value': content,
                    'representation': 'storage'
                }
            }
        }
        
        response = requests.put(
            f"{self.confluence_url}/rest/api/content/{page_id}",
            headers=self.headers,
            data=json.dumps(payload)
        )
        
        if response.status_code == 200:
            return response.json()
        else:
            print(f"Error updating page: {response.status_code}")
            print(response.text[:500])
            return None
    
    def publish(self, markdown_file, space_key='NSBU', parent_id=None, title=None, update_id=None):
        """Main publish method"""
        markdown_path = Path(markdown_file)
        
        if not markdown_path.exists():
            print(f"Error: File not found: {markdown_file}")
            return False
        
        # Default title from filename if not provided
        if not title and not update_id:
            title = markdown_path.stem.replace('-', ' ').replace('_', ' ').title()
        
        print(f"üìÑ Processing: {markdown_path.name}")
        print(f"üîÑ Converting markdown to Confluence storage format...")
        print(f"üìä Optimizing tables and code blocks...")
        
        # Convert markdown to storage format
        storage_content = self.convert_markdown_to_storage(markdown_path)
        if not storage_content:
            return False
        
        print("‚úÖ Conversion complete")
        
        # Update or create page
        if update_id:
            print(f"üìù Updating page ID: {update_id}")
            result = self.update_page(update_id, storage_content, title)
            action = "updated"
        else:
            print(f"üìù Creating new page: {title}")
            result = self.create_page(title, storage_content, space_key, parent_id)
            action = "created"
        
        if result:
            print(f"\n‚úÖ Page {action} successfully!")
            print(f"üìç Title: {result.get('title', 'N/A')}")
            print(f"üÜî Page ID: {result.get('id', 'N/A')}")
            
            # Construct page URL
            page_url = f"{self.confluence_url}/pages/viewpage.action?pageId={result.get('id', '')}"
            print(f"üîó View at: {page_url}")
            return True
        else:
            print(f"\n‚ùå Failed to {action[:-1]} page")
            return False

def main():
    parser = argparse.ArgumentParser(
        description='Publish markdown documents to Confluence (V3 - Optimized)',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument('markdown_file', help='Path to markdown file')
    parser.add_argument('-s', '--space', default='NSBU', help='Confluence space key')
    parser.add_argument('-p', '--parent', help='Parent page ID')
    parser.add_argument('-t', '--title', help='Page title')
    parser.add_argument('-u', '--update', help='Update existing page with this ID')
    parser.add_argument('--url', help='Confluence URL')
    
    args = parser.parse_args()
    
    try:
        publisher = ConfluencePublisher(confluence_url=args.url)
        success = publisher.publish(
            markdown_file=args.markdown_file,
            space_key=args.space,
            parent_id=args.parent,
            title=args.title,
            update_id=args.update
        )
        sys.exit(0 if success else 1)
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)

if __name__ == '__main__':
    main()
